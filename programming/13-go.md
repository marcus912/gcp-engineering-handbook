# Chapter 13: Go Programming Essentials

Go is important because many GCP tools and cloud infrastructure projects are written in Go.

## 13.1 Go Basics

### Hello World

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

### Variables

```go
// Explicit type
var name string = "Alice"
var age int = 30

// Type inference
var city = "Singapore"

// Short declaration (inside functions only)
country := "USA"

// Multiple
var a, b, c int = 1, 2, 3

// Constants
const Pi = 3.14159
```

### Basic Types

```go
// Numbers
int, int8, int16, int32, int64
uint, uint8, uint16, uint32, uint64
float32, float64

// Strings
string

// Boolean
bool

// Zero values
var i int      // 0
var f float64  // 0.0
var s string   // ""
var b bool     // false
```

### Control Flow

```go
// If statement
if x > 0 {
    fmt.Println("positive")
} else if x < 0 {
    fmt.Println("negative")
} else {
    fmt.Println("zero")
}

// If with short statement
if err := doSomething(); err != nil {
    return err
}

// For loop (only loop in Go)
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// While equivalent
for condition {
    // do something
}

// Infinite loop
for {
    // break to exit
}

// Range over slice/array
for index, value := range items {
    fmt.Printf("%d: %v\n", index, value)
}

// Range over map
for key, value := range myMap {
    fmt.Printf("%s: %v\n", key, value)
}

// Switch
switch day {
case "Monday":
    fmt.Println("Start of week")
case "Friday":
    fmt.Println("Almost weekend")
default:
    fmt.Println("Regular day")
}
```

---

## 13.2 Data Structures

### Arrays and Slices

```go
// Array (fixed size)
var arr [5]int
arr := [5]int{1, 2, 3, 4, 5}

// Slice (dynamic)
slice := []int{1, 2, 3}
slice = append(slice, 4, 5)

// Make slice with capacity
slice := make([]int, 0, 10) // len=0, cap=10

// Slice operations
slice[0]          // Access
slice[1:3]        // Slice of slice
len(slice)        // Length
cap(slice)        // Capacity
```

### Maps

```go
// Create map
m := make(map[string]int)
m := map[string]int{
    "one": 1,
    "two": 2,
}

// Operations
m["three"] = 3         // Set
value := m["one"]      // Get
delete(m, "two")       // Delete
len(m)                 // Length

// Check if key exists
value, exists := m["key"]
if exists {
    fmt.Println(value)
}
```

### Structs

```go
// Define struct
type Person struct {
    Name    string
    Age     int
    Email   string
}

// Create instances
p1 := Person{Name: "Alice", Age: 30, Email: "alice@example.com"}
p2 := Person{"Bob", 25, "bob@example.com"}  // Order matters

// Access fields
fmt.Println(p1.Name)
p1.Age = 31
```

---

## 13.3 Functions

### Basic Functions

```go
// Simple function
func greet(name string) string {
    return "Hello, " + name
}

// Multiple parameters
func add(a, b int) int {
    return a + b
}

// Multiple return values
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// Named return values
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return  // returns x and y
}

// Variadic function
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}
```

### Methods

```go
type Rectangle struct {
    Width, Height float64
}

// Method with value receiver
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Method with pointer receiver (can modify)
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

// Usage
rect := Rectangle{10, 5}
fmt.Println(rect.Area())  // 50
rect.Scale(2)
fmt.Println(rect.Area())  // 200
```

---

## 13.4 Interfaces

```go
// Define interface
type Shape interface {
    Area() float64
}

// Types that implement the interface
type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14159 * c.Radius * c.Radius
}

// Function that accepts interface
func printArea(s Shape) {
    fmt.Printf("Area: %.2f\n", s.Area())
}

// Usage
printArea(Rectangle{10, 5})  // Area: 50.00
printArea(Circle{7})          // Area: 153.94
```

### Empty Interface

```go
// interface{} can hold any value (like Object in Java)
var anything interface{}
anything = 42
anything = "hello"
anything = []int{1, 2, 3}

// Type assertion
str, ok := anything.(string)
if ok {
    fmt.Println(str)
}

// Type switch
switch v := anything.(type) {
case int:
    fmt.Println("int:", v)
case string:
    fmt.Println("string:", v)
default:
    fmt.Println("unknown type")
}
```

---

## 13.5 Error Handling

```go
// Errors are values
func readFile(path string) ([]byte, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, fmt.Errorf("failed to read file: %w", err)
    }
    return data, nil
}

// Always check errors
data, err := readFile("config.json")
if err != nil {
    log.Fatal(err)
}

// Custom errors
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("%s: %s", e.Field, e.Message)
}

// Using errors.Is and errors.As
if errors.Is(err, os.ErrNotExist) {
    fmt.Println("file does not exist")
}

var validErr *ValidationError
if errors.As(err, &validErr) {
    fmt.Println("validation failed:", validErr.Field)
}
```

---

## 13.6 Concurrency

### Goroutines

```go
// Start goroutine
go func() {
    fmt.Println("Hello from goroutine")
}()

// Function as goroutine
go processData(data)

// Wait for goroutines
var wg sync.WaitGroup

for i := 0; i < 5; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        fmt.Println("Worker", id)
    }(i)
}

wg.Wait() // Wait for all to finish
```

### Channels

```go
// Create channel
ch := make(chan int)

// Buffered channel
ch := make(chan int, 10)

// Send and receive
go func() {
    ch <- 42  // Send
}()
value := <-ch  // Receive

// Close channel
close(ch)

// Range over channel
for value := range ch {
    fmt.Println(value)
}

// Select (like switch for channels)
select {
case msg := <-ch1:
    fmt.Println("from ch1:", msg)
case msg := <-ch2:
    fmt.Println("from ch2:", msg)
case <-time.After(1 * time.Second):
    fmt.Println("timeout")
default:
    fmt.Println("no message")
}
```

### Worker Pool Pattern

```go
func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        results <- job * 2
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)

    // Start workers
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    // Send jobs
    for j := 1; j <= 9; j++ {
        jobs <- j
    }
    close(jobs)

    // Collect results
    for a := 1; a <= 9; a++ {
        fmt.Println(<-results)
    }
}
```

---

## 13.7 Common Packages

### fmt - Formatting

```go
fmt.Println("Hello")           // Print with newline
fmt.Printf("Name: %s\n", name) // Formatted print
fmt.Sprintf("Age: %d", age)    // Return formatted string

// Format verbs
%v  // Default format
%+v // With field names (structs)
%#v // Go syntax representation
%T  // Type
%d  // Decimal integer
%s  // String
%f  // Float
%t  // Boolean
```

### net/http - HTTP Client/Server

```go
// HTTP GET
resp, err := http.Get("https://api.example.com/data")
if err != nil {
    log.Fatal(err)
}
defer resp.Body.Close()
body, _ := io.ReadAll(resp.Body)

// HTTP Server
http.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
})
http.ListenAndServe(":8080", nil)
```

### encoding/json - JSON

```go
type Person struct {
    Name  string `json:"name"`
    Email string `json:"email,omitempty"`
}

// Marshal (struct to JSON)
p := Person{Name: "Alice", Email: "alice@example.com"}
jsonData, _ := json.Marshal(p)
fmt.Println(string(jsonData))

// Unmarshal (JSON to struct)
var p2 Person
json.Unmarshal(jsonData, &p2)
```

### os - Operating System

```go
// Environment variables
os.Getenv("HOME")
os.Setenv("MY_VAR", "value")

// File operations
data, _ := os.ReadFile("file.txt")
os.WriteFile("file.txt", data, 0644)

// Command line args
os.Args[0]  // Program name
os.Args[1]  // First argument
```

---

## 13.8 Writing a CLI Tool

```go
package main

import (
    "flag"
    "fmt"
    "os"
)

func main() {
    // Define flags
    name := flag.String("name", "World", "Name to greet")
    count := flag.Int("count", 1, "Number of greetings")
    verbose := flag.Bool("verbose", false, "Verbose output")

    flag.Parse()

    // Use flags
    for i := 0; i < *count; i++ {
        if *verbose {
            fmt.Printf("[%d] ", i+1)
        }
        fmt.Printf("Hello, %s!\n", *name)
    }

    // Positional arguments
    args := flag.Args()
    if len(args) > 0 {
        fmt.Println("Additional args:", args)
    }
}

// Usage: ./greet -name=Alice -count=3 -verbose
```

---

## Chapter 13 Review Questions

1. What's the difference between arrays and slices in Go?

2. How do you handle errors in Go?

3. Explain goroutines and channels.

4. How do interfaces work in Go?

5. Write a function that makes an HTTP GET request and returns the response body.

---

## Key Takeaways

1. **Go is simple** - Few keywords, explicit error handling
2. **Errors are values** - Always check them
3. **Goroutines are lightweight** - Use them liberally
4. **Channels for communication** - Don't share memory
5. **Interfaces are implicit** - No "implements" keyword
6. **Standard library is powerful** - net/http, encoding/json, etc.

---

[Next Chapter: Python for Cloud Engineers â†’](./14-python.md)
